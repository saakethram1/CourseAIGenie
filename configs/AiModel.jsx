const {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
    
  } = require("@google/generative-ai");
  
  const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseMimeType: "application/json",
  };
 
    export const GenerateCourseLayout_AI = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate a Course Tutorial on Following Detail With field as Course Name,Description, Along with ChapterName,about, Duration : Category:'programming',Topic:Python ,Level:Basic,Duration:1 Hours, NoofChapters:5, in JSON format"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"CourseName\": \"Python Fundamentals for Beginners\",\n  \"Description\": \"This course provides a comprehensive introduction to the Python programming language.  It covers the fundamental concepts necessary to write basic Python programs, understand core syntax, and solve simple programming problems.  No prior programming experience is required.\",\n  \"Category\": \"programming\",\n  \"Topic\": \"Python\",\n  \"Level\": \"Basic\",\n  \"Duration\": \"1 Hours\",\n  \"NoofChapters\": 5,\n  \"Chapters\": [\n    {\n      \"ChapterName\": \"Introduction to Python and Setup\",\n      \"about\": \"This chapter introduces the Python programming language, its history, and why it's so popular. We'll guide you through installing Python and setting up a development environment, including choosing an IDE or text editor.\",\n      \"Duration\": \"15 minutes\",\n      \"Topics\": [\n        \"What is Python?\",\n        \"Why learn Python?\",\n        \"Installing Python on Windows, macOS, and Linux\",\n        \"Choosing a code editor (VS Code, PyCharm, etc.)\",\n        \"Running your first Python program (Hello, World!)\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Variables, Data Types, and Operators\",\n      \"about\": \"Learn about different data types in Python (integers, floats, strings, booleans) and how to store data using variables. Understand how to perform basic arithmetic and logical operations.\",\n      \"Duration\": \"20 minutes\",\n      \"Topics\": [\n        \"Variables: Naming conventions and assignment\",\n        \"Data Types: Integers, floats, strings, booleans\",\n        \"Arithmetic operators: +, -, *, /, %, **\",\n        \"Comparison operators: ==, !=, >, <, >=, <=\",\n        \"Logical operators: and, or, not\",\n        \"Type conversion\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Control Flow: Conditional Statements\",\n      \"about\": \"Discover how to control the flow of your program using conditional statements (`if`, `elif`, `else`).  Learn to execute different blocks of code based on specific conditions.\",\n      \"Duration\": \"15 minutes\",\n      \"Topics\": [\n        \"The `if` statement\",\n        \"The `elif` (else if) statement\",\n        \"The `else` statement\",\n        \"Nested conditional statements\",\n        \"Using comparison and logical operators in conditions\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Loops: Iterating Through Data\",\n      \"about\": \"Master the use of loops (`for` and `while`) to repeat blocks of code. Learn how to iterate through sequences (strings, lists, etc.) and perform repetitive tasks efficiently.\",\n      \"Duration\": \"15 minutes\",\n      \"Topics\": [\n        \"The `for` loop: Iterating over sequences\",\n        \"The `while` loop: Repeating code until a condition is met\",\n        \"Using `break` and `continue` statements\",\n        \"Nested loops\",\n        \"Looping through strings and lists\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Introduction to Data Structures: Lists\",\n      \"about\": \"This chapter introduces the concept of lists, one of the most fundamental data structures in Python. Learn how to create, access, modify, and manipulate lists to store collections of data.\",\n      \"Duration\": \"15 minutes\",\n      \"Topics\": [\n        \"What is a list?\",\n        \"Creating lists\",\n        \"Accessing list elements (indexing)\",\n        \"Modifying list elements\",\n        \"List methods (append, insert, remove, pop, len, etc.)\",\n        \"List slicing\"\n      ]\n    }\n  ]\n}\n```\n"},
          ],
        },
      ],
    });

  
  
   export const GenerateChapterContent_AI = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: " {text: \"Explain the concept in Detail on Topic:c++,Chapter:Memory Management and Data Structures, in JSON Format with list of array, with field as title,explanation on given chapter in detail, Code Example(Code field in precode tag) if applicable\\n\"}"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"topic\": \"C++ Memory Management and Data Structures\",\n  \"chapters\": [\n    {\n      \"title\": \"Introduction to Memory Management in C++\",\n      \"explanation\": \"C++ offers fine-grained control over memory management, crucial for performance and resource utilization.  It contrasts with languages with automatic garbage collection. Memory is typically managed through the heap and stack. The *stack* is used for local variables and function calls, and memory is automatically allocated and deallocated when a function enters and exits. The *heap* is a larger pool of memory where you can dynamically allocate and deallocate memory as needed during program execution. Manual memory management comes with responsibilities: allocating memory when needed and, crucially, deallocating it when it's no longer used to prevent memory leaks. Ignoring this leads to problems like memory leaks, dangling pointers, and segmentation faults. Understanding memory management is fundamental for building robust and efficient C++ applications.\",\n      \"code_example\": null\n    },\n    {\n      \"title\": \"Dynamic Memory Allocation: `new` and `delete`\",\n      \"explanation\": \"C++ provides `new` and `delete` operators for dynamic memory allocation. `new` allocates memory on the heap and returns a pointer to the allocated memory.  `delete` deallocates memory previously allocated with `new`. When allocating arrays dynamically, you should use `new[]` and `delete[]` respectively.  Mismatched allocation/deallocation (e.g., using `delete` on memory allocated with `new[]`) leads to undefined behavior. Always ensure every `new` is paired with a corresponding `delete` (or `delete[]`) to prevent memory leaks.\",\n      \"code_example\": {\n        \"language\": \"cpp\",\n        \"code\": \"<pre><code>#include <iostream>\\n\\nint main() {\\n  // Allocate an integer on the heap\\n  int* ptr = new int;\\n  *ptr = 10;\\n  std::cout << \\\"Value: \\\" << *ptr << std::endl;\\n\\n  // Deallocate the memory\\n  delete ptr;\\n  ptr = nullptr; // Good practice to avoid dangling pointer\\n\\n  // Allocate an array of integers on the heap\\n  int* arr = new int[5];\\n  for (int i = 0; i < 5; ++i) {\\n    arr[i] = i * 2;\\n  }\\n\\n  for (int i = 0; i < 5; ++i) {\\n    std::cout << \\\"arr[\\\" << i << \\\"] = \\\" << arr[i] << std::endl;\\n  }\\n\\n  // Deallocate the array\\n  delete[] arr;\\n  arr = nullptr;\\n\\n  return 0;\\n}</code></pre>\"\n      }\n    },\n    {\n      \"title\": \"Memory Leaks and Dangling Pointers\",\n      \"explanation\": \"*Memory leaks* occur when memory is allocated but never deallocated, leading to gradual consumption of available memory. Over time, this can cause performance degradation or even program crashes. *Dangling pointers* are pointers that point to memory that has already been deallocated.  Accessing a dangling pointer results in undefined behavior, which can manifest as crashes or unpredictable program behavior. To avoid these problems, always remember to `delete` any memory that was `new`ed, and set pointers to `nullptr` after deletion to prevent accidental reuse of dangling pointers.\",\n      \"code_example\": {\n        \"language\": \"cpp\",\n        \"code\": \"<pre><code>#include <iostream>\\n\\nvoid memoryLeak() {\\n  int* ptr = new int; // Memory allocated but never deallocated\\n  *ptr = 5;\\n  //No delete here, creating a memory leak\\n}\\n\\nvoid danglingPointer() {\\n  int* ptr = new int;\\n  *ptr = 10;\\n  delete ptr;\\n  // ptr is now a dangling pointer\\n  // std::cout << *ptr << std::endl; // Undefined behavior!\\n  ptr = nullptr; // Correct way: set to nullptr\\n}\\n\\nint main() {\\n  memoryLeak(); // Example of a memory leak\\n  danglingPointer(); // Example of a dangling pointer (avoid accessing it after deletion)\\n  return 0;\\n}</code></pre>\"\n      }\n    },\n     {\n      \"title\": \"Smart Pointers (RAII): `unique_ptr`, `shared_ptr`, and `weak_ptr`\",\n      \"explanation\": \"Smart pointers automate memory management using the Resource Acquisition Is Initialization (RAII) principle. When a smart pointer goes out of scope, it automatically releases the memory it owns, preventing memory leaks.  `unique_ptr` provides exclusive ownership. Only one `unique_ptr` can point to a given piece of memory. It is ideal when you want to ensure that only one object is responsible for deleting a resource.  `shared_ptr` allows multiple pointers to share ownership of a single resource.  The resource is automatically deallocated when the last `shared_ptr` pointing to it is destroyed. `weak_ptr` is a non-owning pointer to a resource managed by a `shared_ptr`. It allows you to observe a resource without participating in ownership. It can be used to check if the resource is still alive before accessing it, preventing dangling pointer issues.  Using smart pointers is highly recommended to avoid manual memory management and its associated pitfalls.\",\n      \"code_example\": {\n        \"language\": \"cpp\",\n        \"code\": \"<pre><code>#include <iostream>\\n#include <memory>\\n\\nint main() {\\n  // unique_ptr: exclusive ownership\\n  std::unique_ptr<int> uniquePtr(new int(20));\\n  std::cout << \\\"Unique ptr value: \\\" << *uniquePtr << std::endl;\\n  // uniquePtr automatically deleted when it goes out of scope\\n\\n  // shared_ptr: shared ownership\\n  std::shared_ptr<int> sharedPtr1(new int(30));\\n  std::shared_ptr<int> sharedPtr2 = sharedPtr1; // Both point to the same memory\\n  std::cout << \\\"Shared ptr count: \\\" << sharedPtr1.use_count() << std::endl; // Output: 2\\n  std::cout << \\\"Shared ptr value: \\\" << *sharedPtr1 << std::endl;\\n  // Memory deleted when both sharedPtr1 and sharedPtr2 go out of scope\\n\\n  // weak_ptr: non-owning observer\\n  std::weak_ptr<int> weakPtr = sharedPtr1;\\n  if (auto sharedPtr3 = weakPtr.lock()) { // Check if the resource is still alive\\n    std::cout << \\\"Weak ptr value (if alive): \\\" << *sharedPtr3 << std::endl;\\n  } else {\\n    std::cout << \\\"Resource no longer available.\\\" << std::endl;\\n  }\\n\\n    sharedPtr1.reset();\\n    sharedPtr2.reset();\\n\\n     if (auto sharedPtr3 = weakPtr.lock()) { // Check if the resource is still alive\\n    std::cout << \\\"Weak ptr value (if alive): \\\" << *sharedPtr3 << std::endl;\\n  } else {\\n    std::cout << \\\"Resource no longer available.\\\" << std::endl;  //This line get executed\\n  }\\n\\n  return 0;\\n}</code></pre>\"\n      }\n    },\n    {\n      \"title\": \"Data Structures: Arrays, Linked Lists, Stacks, Queues, Trees, and Hash Tables\",\n      \"explanation\": \"Data structures are ways of organizing and storing data to facilitate efficient access and modification. Each data structure has different trade-offs in terms of storage space, access time, insertion time, and deletion time.\\n\\n*   **Arrays:** Contiguous blocks of memory that store elements of the same data type. Provide fast access to elements using their index (O(1)). Insertion and deletion in the middle of the array can be slow (O(n)).\\n*   **Linked Lists:** A sequence of nodes, each containing data and a pointer to the next node. Insertion and deletion are efficient (O(1) if you have a pointer to the node), but accessing an element requires traversing the list from the beginning (O(n)).\\n*   **Stacks:** A LIFO (Last-In, First-Out) data structure. Elements are added and removed from the top of the stack. Operations: push (add to the top), pop (remove from the top), peek (view the top element). Implemented using arrays or linked lists.\\n*   **Queues:** A FIFO (First-In, First-Out) data structure. Elements are added to the rear and removed from the front. Operations: enqueue (add to the rear), dequeue (remove from the front), peek (view the front element). Implemented using arrays or linked lists.\\n*   **Trees:** Hierarchical data structures composed of nodes connected by edges. A root node is the topmost node. Common types include binary trees (each node has at most two children) and binary search trees (BSTs) which follow ordering properties, making search efficient. Operations include insert, delete, search, traversal.\\n*   **Hash Tables:** Data structures that use a hash function to map keys to their corresponding values. They provide fast average-case access, insertion, and deletion (O(1)), but worst-case performance can be O(n) if many keys map to the same index (collision). Collision resolution techniques include chaining and open addressing.\",\n      \"code_example\": null\n    },\n    {\n      \"title\": \"Implementing a Simple Linked List\",\n      \"explanation\": \"This demonstrates a simple singly linked list with basic insert and print functionality.  It illustrates how to create nodes, link them together, and traverse the list. Proper memory management with `new` and `delete` is crucial to avoid leaks.\",\n      \"code_example\": {\n        \"language\": \"cpp\",\n        \"code\": \"<pre><code>#include <iostream>\\n\\nstruct Node {\\n  int data;\\n  Node* next;\\n  Node(int val) : data(val), next(nullptr) {}\\n};\\n\\nclass LinkedList {\\nprivate:\\n  Node* head;\\n\\npublic:\\n  LinkedList() : head(nullptr) {}\\n\\n  void insert(int val) {\\n    Node* newNode = new Node(val);\\n    newNode->next = head;\\n    head = newNode;\\n  }\\n\\n  void print() {\\n    Node* current = head;\\n    while (current != nullptr) {\\n      std::cout << current->data << \\\" \\\";\\n      current = current->next;\\n    }\\n    std::cout << std::endl;\\n  }\\n\\n  ~LinkedList() {\\n    Node* current = head;\\n    while (current != nullptr) {\\n      Node* next = current->next;\\n      delete current;\\n      current = next;\\n    }\\n    head = nullptr;\\n  }\\n};\\n\\nint main() {\\n  LinkedList list;\\n  list.insert(10);\\n  list.insert(20);\\n  list.insert(30);\\n  list.print(); // Output: 30 20 10\\n  return 0;\\n}</code></pre>\"\n      }\n    },\n    {\n      \"title\": \"Implementing a Simple Stack using Arrays\",\n      \"explanation\": \"Demonstrates a fixed-size stack using an array.  It illustrates the push and pop operations, along with checks for stack overflow and underflow. This implementation has a limitation of a fixed capacity. Resizing to overcome fixed capacity can be achieved with Dynamic arrays (using `new[]`) and memory must be managed by `delete[]`\",\n      \"code_example\": {\n        \"language\": \"cpp\",\n        \"code\": \"<pre><code>#include <iostream>\\n\\nclass Stack {\\nprivate:\\n  int* arr;\\n  int top;\\n  int capacity;\\n\\npublic:\\n  Stack(int cap) : capacity(cap), top(-1) {\\n    arr = new int[capacity];\\n  }\\n\\n  bool isFull() {\\n    return top == capacity - 1;\\n  }\\n\\n  bool isEmpty() {\\n    return top == -1;\\n  }\\n\\n  void push(int val) {\\n    if (isFull()) {\\n      std::cout << \\\"Stack Overflow!\\\" << std::endl;\\n      return;\\n    }\\n    arr[++top] = val;\\n  }\\n\\n  int pop() {\\n    if (isEmpty()) {\\n      std::cout << \\\"Stack Underflow!\\\" << std::endl;\\n      return -1; // Or throw an exception\\n    }\\n    return arr[top--];\\n  }\\n\\n  ~Stack() {\\n    delete[] arr;\\n  }\\n};\\n\\nint main() {\\n  Stack stack(5);\\n  stack.push(10);\\n  stack.push(20);\\n  stack.push(30);\\n  std::cout << \\\"Popped: \\\" << stack.pop() << std::endl; // Output: 30\\n  return 0;\\n}</code></pre>\"\n      }\n    }\n\n  ]\n}\n```"},
          ],
        },
      ],
    });
  
    // const result = await chatSession.sendMessage("INSERT_INPUT_HERE");
    // console.log(result.response.text());
  
    // const result = await GenerateCourseLayout_AI.sendMessage("INSERT_INPUT_HERE");
    // console.log(result.response.text());
  